/**
 * ü™ê ExoplanetSceneManagerAdvanced
 * 
 * Version avanc√©e avec toutes les fonctionnalit√©s du syst√®me solaire :
 * - Mat√©riaux avec bump mapping et normal mapping
 * - Atmosph√®res conditionnelles selon classification
 * - Anneaux pour g√©antes gazeuses
 * - Lunes proc√©durales
 * - √âclairage et ombres r√©alistes
 * - Effets de s√©lection avanc√©s
 * - Shaders personnalis√©s pour plan√®tes chaudes
 */

import * as THREE from 'three';

export class ExoplanetSceneManagerAdvanced {
    constructor(scene, camera, renderer) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        this.exoplanets = [];
        this.orbits = [];
        this.atmospheres = [];
        this.rings = [];
        this.moons = [];
        this.textureLoader = new THREE.TextureLoader();
        
        // Facteurs d'√©chelle identiques au syst√®me solaire
        this.scaleFactors = {
            distance: 7504,  // 1 UA = 7504 unit√©s
            radius: 10,      // Multiplicateur pour les rayons
        };
        
        // Couleurs des orbites selon le type
        this.orbitColors = {
            grassland: 0x7CFC00,   // Vert prairie
            jungle: 0x228B22,      // Vert for√™t
            snowy: 0xE0FFFF,       // Cyan clair
            tundra: 0x87CEEB,      // Bleu ciel
            arid: 0xD2691E,        // Marron orang√©
            sandy: 0xF4A460,       // Sable
            dusty: 0xC0C0C0,       // Gris
            martian: 0xFF4500,     // Rouge orang√©
            barren: 0x696969,      // Gris fonc√©
            marshy: 0x556B2F,      // Vert olive
            gaseous: 0xFFA500,     // Orange
            methane: 0x4169E1,     // Bleu royal
            default: 0xFFFFFF      // Blanc
        };
        
        // Couleurs des marqueurs selon le type d'exoplan√®te (m√™me que orbites)
        this.markerColors = {
            grassland: 0x7CFC00,   // Vert prairie
            jungle: 0x228B22,      // Vert for√™t
            snowy: 0xE0FFFF,       // Cyan clair
            tundra: 0x87CEEB,      // Bleu ciel
            arid: 0xD2691E,        // Marron orang√©
            sandy: 0xF4A460,       // Sable
            dusty: 0xC0C0C0,       // Gris
            martian: 0xFF4500,     // Rouge orang√©
            barren: 0x696969,      // Gris fonc√©
            marshy: 0x556B2F,      // Vert olive
            gaseous: 0xFFA500,     // Orange
            methane: 0x4169E1,     // Bleu royal
            default: 0xFFFFFF      // Blanc
        };
        
        // Stockage des marqueurs cr√©√©s pour nettoyage
        this.createdMarkers = [];
        
        // Configuration des atmosph√®res
        this.atmosphereConfig = {
            grassland: { color: 0x87CEEB, opacity: 0.3 },
            jungle: { color: 0x32CD32, opacity: 0.4 },
            snowy: { color: 0xE0FFFF, opacity: 0.2 },
            tundra: { color: 0x87CEEB, opacity: 0.25 },
            arid: { color: 0xDEB887, opacity: 0.15 },
            gaseous: { color: 0xFFA500, opacity: 0.6 },
            methane: { color: 0x4169E1, opacity: 0.5 }
        };
        
        console.log('üé® ExoplanetSceneManagerAdvanced initialis√© avec fonctionnalit√©s avanc√©es');
    }
    
    /**
     * Cr√©e toutes les exoplan√®tes avec fonctionnalit√©s avanc√©es
     */
    createExoplanets(processedPlanets, sunRadius = 698.88) {
        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('ü™ê CR√âATION AVANC√âE DES EXOPLAN√àTES');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log(`üìä Plan√®tes √† cr√©er: ${processedPlanets.length}`);
        console.log(`‚òÄÔ∏è Rayon du Soleil: ${sunRadius.toFixed(2)} unit√©s`);
        
        this.currentSunRadius = sunRadius;
        this.totalPlanets = processedPlanets.length;
        
        // Nettoyer les anciennes exoplan√®tes
        this.clearExoplanets();
        
        processedPlanets.forEach((planet, index) => {
            this.createAdvancedExoplanet(planet, index);
        });
        
        console.log(`‚úÖ ${this.exoplanets.length} exoplan√®tes avanc√©es cr√©√©es!`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    }
    
    /**
     * Cr√©e une exoplan√®te avec toutes les fonctionnalit√©s avanc√©es
     */
    async createAdvancedExoplanet(planet, index) {
        const {
            name, radius, distance, temperature, classification,
            type, texturePath, confidence
        } = planet;
        
        console.log(`\nüåç Cr√©ation avanc√©e: ${name}`);
        console.log(`   Type: ${classification} (${type})`);
        console.log(`   Rayon: ${radius} R‚äï, Distance: ${distance} UA`);
        
        // Calculer les dimensions
        const visualRadius = this.calculateVisualRadius(radius);
        const visualDistance = this.calculateVisualDistance(distance);
        
        // Cr√©er un groupe pour la plan√®te (comme le syst√®me solaire)
        const planetSystem = new THREE.Group();
        
        // Cr√©er l'orbite color√©e et l'ajouter DIRECTEMENT √† la sc√®ne
        const orbitColor = this.orbitColors[type] || this.orbitColors.default;
        const orbit = this.createOrbit(visualDistance, orbitColor);
        this.scene.add(orbit);  // Ajouter directement √† la sc√®ne
        this.orbits.push(orbit);
        
        // Cr√©er la g√©om√©trie haute qualit√©
        const geometry = new THREE.SphereGeometry(visualRadius, 64, 64);
        
        try {
            // Charger les textures
            const texture = await this.textureLoader.loadAsync(texturePath);
            
            // Cr√©er le mat√©riau avanc√©
            const material = await this.createAdvancedMaterial(texture, planet);
            
            // Cr√©er le mesh principal
            const mesh = new THREE.Mesh(geometry, material);
            
            // Position initiale
            const angle = (index / this.totalPlanets) * Math.PI * 2;
            mesh.position.x = visualDistance * Math.cos(angle);
            mesh.position.y = 0;
            
            // Configuration des ombres
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.renderOrder = 1; // ‚úÖ Rendre les plan√®tes APR√àS les orbites
            
            // Donn√©es utilisateur
            mesh.userData = {
                name, classification, type, distance: visualDistance,
                radius: visualRadius, orbitSpeed: this.calculateOrbitSpeed(distance),
                currentAngle: angle, temperature, confidence
            };
            
            // Ajouter la plan√®te au groupe
            planetSystem.add(mesh);
            
            // Ajouter le groupe complet √† la sc√®ne
            this.scene.add(planetSystem);
            this.exoplanets.push(mesh);
            
            // Cr√©er l'atmosph√®re si applicable
            await this.createAtmosphere(mesh, planet);
            
            // Cr√©er les anneaux si g√©ante gazeuse
            if (type === 'gas_giant' && radius > 3) {
                await this.createRings(mesh, planet);
            }
            
            // Cr√©er les lunes selon la taille
            if (radius > 1.5) {
                await this.createMoons(mesh, planet);
            }
            
            // Cr√©er le marqueur pour l'exoplan√®te (int√©gration au PlanetMarkerSystem)
            this.createExoplanetMarker(mesh, planet);
            
            console.log(`   ‚úÖ Exoplan√®te avanc√©e cr√©√©e avec succ√®s`);
            
        } catch (error) {
            console.warn(`   ‚ö†Ô∏è Erreur texture, utilisation couleur par d√©faut`);
            await this.createFallbackExoplanet(geometry, planet, visualDistance, angle, index);
        }
    }
    
    /**
     * Cr√©e un mat√©riau avanc√© avec bump mapping et effets
     */
    async createAdvancedMaterial(texture, planet) {
        const { type, temperature, classification } = planet;
        
        // Mat√©riau de base avec texture
        const materialConfig = {
            map: texture,
            roughness: 0.7,
            metalness: 0.1
        };
        
        // Ajouter bump mapping si disponible
        try {
            const bumpPath = this.getBumpMapPath(classification);
            if (bumpPath) {
                const bumpTexture = await this.textureLoader.loadAsync(bumpPath);
                materialConfig.bumpMap = bumpTexture;
                materialConfig.bumpScale = 0.5;
            }
        } catch (e) {
            console.log(`   üìù Pas de bump map pour ${classification}`);
        }
        
        // Ajouter normal mapping si disponible
        try {
            const normalPath = this.getNormalMapPath(classification);
            if (normalPath) {
                const normalTexture = await this.textureLoader.loadAsync(normalPath);
                materialConfig.normalMap = normalTexture;
                materialConfig.normalScale = new THREE.Vector2(0.5, 0.5);
            }
        } catch (e) {
            console.log(`   üìù Pas de normal map pour ${classification}`);
        }
        
        // Effets √©missifs pour plan√®tes chaudes
        if (temperature > 800) {
            materialConfig.emissive = new THREE.Color(0xff4400);
            materialConfig.emissiveIntensity = Math.min((temperature - 800) / 1000, 0.3);
            console.log(`   üî• Plan√®te chaude: √©mission ${materialConfig.emissiveIntensity.toFixed(2)}`);
        }
        
        // Mat√©riau sp√©culaire pour plan√®tes oc√©aniques
        if (type === 'grassland' || type === 'jungle') {
            materialConfig.roughness = 0.3;
            materialConfig.metalness = 0.2;
        }
        
        return new THREE.MeshStandardMaterial(materialConfig);
    }
    
    /**
     * Cr√©e une atmosph√®re conditionnelle selon la classification
     */
    async createAtmosphere(planetMesh, planet) {
        const { type, radius } = planet;
        const atmosphereConfig = this.atmosphereConfig[type];
        
        if (!atmosphereConfig) return;
        
        const atmosphereRadius = planetMesh.userData.radius + (planetMesh.userData.radius * 0.1);
        const atmosphereGeometry = new THREE.SphereGeometry(atmosphereRadius, 32, 32);
        
        const atmosphereMaterial = new THREE.MeshPhongMaterial({
            color: atmosphereConfig.color,
            transparent: true,
            opacity: atmosphereConfig.opacity,
            depthTest: true,
            depthWrite: false,
            side: THREE.BackSide
        });
        
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        atmosphere.userData = { type: 'atmosphere', parent: planetMesh.userData.name };
        atmosphere.renderOrder = 2; // ‚úÖ Rendre l'atmosph√®re APR√àS la plan√®te
        
        planetMesh.add(atmosphere);
        this.atmospheres.push(atmosphere);
        
        console.log(`   üå´Ô∏è Atmosph√®re ${type} cr√©√©e (opacit√©: ${atmosphereConfig.opacity})`);
    }
    
    /**
     * Cr√©e des anneaux pour les g√©antes gazeuses
     */
    async createRings(planetMesh, planet) {
        const { radius, type } = planet;
        
        if (type !== 'gas_giant') return;
        
        const innerRadius = planetMesh.userData.radius * 1.2;
        const outerRadius = planetMesh.userData.radius * 2.0;
        
        const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
        
        // Texture d'anneau selon le type
        let ringTexture;
        try {
            const ringPath = type === 'methane' ? 
                '/images/uranus_ring.png' : '/images/saturn_ring.png';
            ringTexture = await this.textureLoader.loadAsync(ringPath);
        } catch (e) {
            console.log(`   üìù Texture d'anneau par d√©faut`);
        }
        
        const ringMaterial = new THREE.MeshStandardMaterial({
            map: ringTexture,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        
        const rings = new THREE.Mesh(ringGeometry, ringMaterial);
        rings.rotation.x = -Math.PI / 2;
        rings.userData = { type: 'rings', parent: planetMesh.userData.name };
        
        planetMesh.add(rings);
        this.rings.push(rings);
        
        console.log(`   üíç Anneaux cr√©√©s (${innerRadius.toFixed(1)} - ${outerRadius.toFixed(1)})`);
    }
    
    /**
     * Cr√©e des lunes proc√©durales selon la taille de la plan√®te
     */
    async createMoons(planetMesh, planet) {
        const { radius, type } = planet;
        
        // Nombre de lunes bas√© sur la taille
        const moonCount = Math.min(Math.floor(radius / 2), 4);
        if (moonCount === 0) return;
        
        for (let i = 0; i < moonCount; i++) {
            const moonRadius = planetMesh.userData.radius * (0.1 + Math.random() * 0.15);
            const orbitDistance = planetMesh.userData.radius * (2 + i * 0.5);
            
            const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
            
            // Mat√©riau de lune
            const moonMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(orbitDistance, 0, 0);
            moon.castShadow = true;
            moon.receiveShadow = true;
            
            moon.userData = {
                type: 'moon',
                parent: planetMesh.userData.name,
                orbitDistance: orbitDistance,
                orbitSpeed: 0.01 + Math.random() * 0.02,
                currentAngle: Math.random() * Math.PI * 2
            };
            
            planetMesh.add(moon);
            this.moons.push(moon);
        }
        
        console.log(`   üåô ${moonCount} lunes cr√©√©es`);
    }
    
    /**
     * Met √† jour les animations avec lunes
     */
    update(deltaTime = 0.016) {
        // Animation des exoplan√®tes
        this.exoplanets.forEach(planet => {
            const { distance, orbitSpeed, currentAngle } = planet.userData;
            
            // Orbite
            const newAngle = currentAngle + orbitSpeed;
            planet.userData.currentAngle = newAngle;
            planet.position.x = distance * Math.cos(newAngle);
            planet.position.z = distance * Math.sin(newAngle);
            
            // Rotation
            planet.rotation.y += 0.001;
        });
        
        // Animation des lunes
        this.moons.forEach(moon => {
            const { orbitDistance, orbitSpeed, currentAngle } = moon.userData;
            
            const newAngle = currentAngle + orbitSpeed;
            moon.userData.currentAngle = newAngle;
            moon.position.x = orbitDistance * Math.cos(newAngle);
            moon.position.z = orbitDistance * Math.sin(newAngle);
            moon.rotation.y += 0.005;
        });
    }
    
    /**
     * Obtient le chemin de la bump map selon la classification
     */
    getBumpMapPath(classification) {
        const bumpMaps = {
            martian: '/images/marsbump.jpg',
            barren: '/images/moonbump.jpg',
            arid: '/images/mercurybump.jpg'
        };
        return bumpMaps[classification];
    }
    
    /**
     * Obtient le chemin de la normal map selon la classification
     */
    getNormalMapPath(classification) {
        // Chemins vers les normal maps si disponibles
        return null; // √Ä impl√©menter si normal maps disponibles
    }
    
    /**
     * Cr√©e une exoplan√®te de secours avec couleur
     */
    async createFallbackExoplanet(geometry, planet, visualDistance, angle, index) {
        const fallbackColor = this.getFallbackColor(planet.type);
        const material = new THREE.MeshStandardMaterial({
            color: fallbackColor,
            roughness: 0.7,
            metalness: 0.1
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = visualDistance * Math.cos(angle);
        mesh.position.z = visualDistance * Math.sin(angle);
        mesh.position.y = 0;
        
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        
        mesh.userData = {
            name: planet.name,
            classification: planet.classification,
            type: planet.type,
            distance: visualDistance,
            radius: this.calculateVisualRadius(planet.radius),
            orbitSpeed: this.calculateOrbitSpeed(planet.distance),
            currentAngle: angle,
            temperature: planet.temperature,
            confidence: planet.confidence
        };
        
        // Ajouter la plan√®te au groupe
        planetSystem.add(mesh);
        
        // Ajouter le groupe complet √† la sc√®ne
        this.scene.add(planetSystem);
        this.exoplanets.push(mesh);
        
        // Cr√©er le marqueur pour l'exoplan√®te de secours
        this.createExoplanetMarker(mesh, planet);
    }
    
    /**
     * Cr√©e un marqueur pour l'exoplan√®te en utilisant le PlanetMarkerSystem existant
     */
    createExoplanetMarker(exoplanetMesh, planetData) {
        // V√©rifier que le PlanetMarkerSystem est disponible
        if (!window.planetMarkerSystem) {
            console.warn(`   ‚ö†Ô∏è PlanetMarkerSystem non disponible pour ${planetData.name}`);
            return;
        }
        
        const { name, type, classification } = planetData;
        
        // Obtenir la couleur selon le type d'exoplan√®te
        const markerColor = this.markerColors[type] || this.markerColors.default;
        
        // Cr√©er un identifiant unique pour l'exoplan√®te (en minuscules pour coh√©rence)
        const exoplanetId = name.toLowerCase().replace(/\s+/g, '_');
        
        // Temporairement ajouter la couleur personnalis√©e au syst√®me de marqueurs
        const originalColors = window.planetMarkerSystem.config.planetColors;
        window.planetMarkerSystem.config.planetColors[exoplanetId] = markerColor;
        
        try {
            // Cr√©er le marqueur avec le nom complet de l'exoplan√®te
            const markerGroup = window.planetMarkerSystem.createPlanetMarker(
                exoplanetId,           // ID unique
                exoplanetMesh,         // Mesh de l'exoplan√®te
                name                   // Nom d'affichage (ex: "Kepler-442 b")
            );
            
            // Ajouter le marqueur aux raycastTargets pour le rendre cliquable
            this.addMarkerToRaycastTargets(exoplanetId);
            
            // Stocker l'ID pour le nettoyage ult√©rieur
            this.createdMarkers.push(exoplanetId);
            
            console.log(`   üè∑Ô∏è Marqueur cr√©√© pour ${name} (couleur: #${markerColor.toString(16).padStart(6, '0')})`);
            
        } catch (error) {
            console.error(`   ‚ùå Erreur cr√©ation marqueur pour ${name}:`, error);
        }
        
        // Restaurer les couleurs originales
        window.planetMarkerSystem.config.planetColors = originalColors;
    }
    
    /**
     * Ajoute les marqueurs d'exoplan√®te aux raycastTargets (m√™me logique que le syst√®me solaire)
     */
    addMarkerToRaycastTargets(exoplanetId) {
        if (!window.planetMarkerSystem || !window.raycastTargets) {
            return;
        }
        
        const markerData = window.planetMarkerSystem.markers.get(exoplanetId);
        if (markerData) {
            // Ajouter les √©l√©ments cliquables du marqueur (m√™me logique que script.js)
            window.raycastTargets.push(markerData.ring);
            window.raycastTargets.push(markerData.clickArea);
            console.log(`   üéØ Marqueur ${exoplanetId} ajout√© aux raycastTargets`);
        }
    }
    
    /**
     * M√©thodes utilitaires (identiques √† l'original)
     */
    calculateVisualRadius(radius) {
        const baseRadius = radius * this.scaleFactors.radius;
        return Math.max(baseRadius, 0.5);
    }
    
    calculateVisualDistance(distance) {
        const distanceFromCenter = distance * this.scaleFactors.distance;
        const sunRadius = this.currentSunRadius || 698.88;
        return distanceFromCenter + sunRadius;
    }
    
    calculateOrbitSpeed(distance) {
        return 0.001 / Math.sqrt(distance);
    }
    
    createOrbit(radius, color) {
        const orbitPath = new THREE.EllipseCurve(0, 0, radius, radius, 0, 2 * Math.PI, false, 0);
        const pathPoints = orbitPath.getPoints(128);
        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
        
        const orbitMaterial = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4,
            depthWrite: true,   // ‚úÖ Activer l'√©criture dans le z-buffer pour occlusion correcte
            depthTest: true     // ‚úÖ Tester la profondeur pour occlusion
        });
        
        const orbit = new THREE.LineLoop(orbitGeometry, orbitMaterial);
        orbit.rotation.x = Math.PI / 2;
        orbit.renderOrder = -1; // ‚úÖ Rendre les orbites AVANT les plan√®tes
        
        return orbit;
    }
    
    getFallbackColor(type) {
        const colors = {
            grassland: 0x7CFC00, jungle: 0x228B22, snowy: 0xFFFFFF,
            tundra: 0x87CEEB, arid: 0xD2691E, sandy: 0xF4A460,
            dusty: 0xC0C0C0, martian: 0xFF4500, barren: 0x696969,
            marshy: 0x556B2F, gaseous: 0xFFA500, methane: 0x4169E1
        };
        return colors[type] || 0x808080;
    }
    
    /**
     * Nettoie toutes les exoplan√®tes et leurs composants
     */
    clearExoplanets() {
        console.log('üßπ Nettoyage avanc√© des exoplan√®tes...');
        
        // Nettoyer les marqueurs d'exoplan√®tes du PlanetMarkerSystem
        this.clearExoplanetMarkers();
        
        // Nettoyer tous les composants
        [...this.exoplanets, ...this.orbits, ...this.atmospheres, 
         ...this.rings, ...this.moons].forEach(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (obj.material.map) obj.material.map.dispose();
                if (obj.material.bumpMap) obj.material.bumpMap.dispose();
                if (obj.material.normalMap) obj.material.normalMap.dispose();
                obj.material.dispose();
            }
            this.scene.remove(obj);
        });
        
        this.exoplanets = [];
        this.orbits = [];
        this.atmospheres = [];
        this.rings = [];
        this.moons = [];
        
        console.log('‚úÖ Nettoyage avanc√© termin√©');
    }
    
    /**
     * Nettoie les marqueurs d'exoplan√®tes du PlanetMarkerSystem
     */
    clearExoplanetMarkers() {
        if (!window.planetMarkerSystem || !window.raycastTargets) {
            return;
        }
        
        console.log(`üè∑Ô∏è Nettoyage de ${this.createdMarkers.length} marqueurs d'exoplan√®tes...`);
        
        this.createdMarkers.forEach(exoplanetId => {
            // Retirer les marqueurs des raycastTargets
            const markerData = window.planetMarkerSystem.markers.get(exoplanetId);
            if (markerData) {
                // Retirer ring et clickArea des raycastTargets
                const ringIndex = window.raycastTargets.indexOf(markerData.ring);
                if (ringIndex > -1) {
                    window.raycastTargets.splice(ringIndex, 1);
                }
                
                const clickIndex = window.raycastTargets.indexOf(markerData.clickArea);
                if (clickIndex > -1) {
                    window.raycastTargets.splice(clickIndex, 1);
                }
                
                console.log(`   üóëÔ∏è Marqueur ${exoplanetId} retir√© des raycastTargets`);
            }
            
            // Supprimer le marqueur du PlanetMarkerSystem
            window.planetMarkerSystem.removeMarker(exoplanetId);
            console.log(`   üóëÔ∏è Marqueur ${exoplanetId} supprim√© du PlanetMarkerSystem`);
        });
        
        // Vider la liste des marqueurs cr√©√©s
        this.createdMarkers = [];
        console.log('‚úÖ Marqueurs d\'exoplan√®tes nettoy√©s');
    }
    
    /**
     * Obtient tous les objets cliquables (exoplan√®tes + lunes + √©toile)
     */
    getClickableObjects() {
        const clickableObjects = [];
        
        // Exoplan√®tes
        this.exoplanets.forEach(planet => {
            clickableObjects.push({
                mesh: planet,
                userData: planet.userData,
                type: 'exoplanet'
            });
        });
        
        // Lunes
        this.moons.forEach(moon => {
            clickableObjects.push({
                mesh: moon,
                userData: moon.userData,
                type: 'moon'
            });
        });
        
        // √âtoile centrale
        if (window.sun && window.currentExoplanets) {
            clickableObjects.push({
                mesh: window.sun,
                userData: {
                    name: this.getKeplerStarName(),
                    type: 'kepler_star',
                    temperature: '5778 K (temp√©rature solaire)',
                    classification: '√âtoile de type G',
                    system: this.getCurrentSystemName()
                },
                type: 'kepler_star'
            });
        }
        
        return clickableObjects;
    }
    
    /**
     * Trouve un objet par son mesh
     */
    findExoplanetByMesh(mesh) {
        // Chercher dans les exoplan√®tes
        const planet = this.exoplanets.find(p => p === mesh);
        if (planet) {
            return { mesh: planet, userData: planet.userData, type: 'exoplanet' };
        }
        
        // Chercher dans les lunes
        const moon = this.moons.find(m => m === mesh);
        if (moon) {
            return { mesh: moon, userData: moon.userData, type: 'moon' };
        }
        
        // √âtoile centrale
        if (mesh === window.sun && window.currentExoplanets) {
            return {
                mesh: mesh,
                userData: {
                    name: this.getKeplerStarName(),
                    type: 'kepler_star',
                    temperature: '5778 K',
                    classification: '√âtoile de type G',
                    system: this.getCurrentSystemName()
                },
                type: 'kepler_star'
            };
        }
        
        return null;
    }
    
    getKeplerStarName() {
        if (window.currentExoplanets && window.currentExoplanets.length > 0) {
            const firstPlanet = window.currentExoplanets[0];
            if (firstPlanet.name) {
                return firstPlanet.name.split(' ')[0];
            }
        }
        return '√âtoile Kepler';
    }
    
    getCurrentSystemName() {
        return this.getKeplerStarName();
    }
    
    /**
     * Affiche les informations d√©taill√©es
     */
    displayInfo() {
        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üìä EXOPLAN√àTES AVANC√âES DANS LA SC√àNE');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        if (this.exoplanets.length === 0) {
            console.log('‚ùå Aucune exoplan√®te dans la sc√®ne');
            return;
        }
        
        this.exoplanets.forEach((planet, index) => {
            const { name, classification, type, distance, radius, temperature, confidence } = planet.userData;
            console.log(`\nüåç ${index + 1}. ${name}`);
            console.log(`   Type: ${classification} (${type})`);
            console.log(`   Rayon: ${radius.toFixed(2)} unit√©s`);
            console.log(`   Distance: ${distance.toFixed(2)} unit√©s`);
            console.log(`   Temp√©rature: ${temperature}K`);
            console.log(`   Confiance: ${confidence}%`);
            
            // Compter les composants
            const moonCount = this.moons.filter(m => m.userData.parent === name).length;
            const hasAtmosphere = this.atmospheres.some(a => a.userData.parent === name);
            const hasRings = this.rings.some(r => r.userData.parent === name);
            
            console.log(`   üåô Lunes: ${moonCount}`);
            console.log(`   üå´Ô∏è Atmosph√®re: ${hasAtmosphere ? 'Oui' : 'Non'}`);
            console.log(`   üíç Anneaux: ${hasRings ? 'Oui' : 'Non'}`);
        });
        
        console.log(`\nüìà STATISTIQUES:`);
        console.log(`   Exoplan√®tes: ${this.exoplanets.length}`);
        console.log(`   Lunes: ${this.moons.length}`);
        console.log(`   Atmosph√®res: ${this.atmospheres.length}`);
        console.log(`   Anneaux: ${this.rings.length}`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    }
}

export default ExoplanetSceneManagerAdvanced;
